# GORM Gen ä½¿ç”¨æŒ‡å—

> ðŸš€ Coze Studio ä½¿ç”¨ GORM Gen è‡ªåŠ¨ç”Ÿæˆç±»åž‹å®‰å…¨çš„æ•°æ®è®¿é—®ä»£ç 

## ðŸ“š ç›®å½•

- [ä»€ä¹ˆæ˜¯ GORM Gen](#ä»€ä¹ˆæ˜¯-gorm-gen)
- [é¡¹ç›®ä¸­çš„ä½¿ç”¨](#é¡¹ç›®ä¸­çš„ä½¿ç”¨)
- [ç”Ÿæˆçš„ä»£ç ç»“æž„](#ç”Ÿæˆçš„ä»£ç ç»“æž„)
- [å¦‚ä½•ä½¿ç”¨](#å¦‚ä½•ä½¿ç”¨)
- [å®žé™…ç¤ºä¾‹](#å®žé™…ç¤ºä¾‹)
- [æœ€ä½³å®žè·µ](#æœ€ä½³å®žè·µ)

---

## ä»€ä¹ˆæ˜¯ GORM Gen

GORM Gen æ˜¯ GORM çš„å®˜æ–¹ä»£ç ç”Ÿæˆå·¥å…·ï¼Œå¯ä»¥ï¼š
- âœ… è‡ªåŠ¨ä»Žæ•°æ®åº“è¡¨ç”Ÿæˆç±»åž‹å®‰å…¨çš„æŸ¥è¯¢ä»£ç 
- âœ… æä¾›ç¼–è¯‘æ—¶ç±»åž‹æ£€æŸ¥ï¼Œé¿å… SQL å­—ç¬¦ä¸²æ‹¼æŽ¥é”™è¯¯
- âœ… æ”¯æŒé“¾å¼è°ƒç”¨ï¼Œä»£ç æ›´ä¼˜é›…
- âœ… å‡å°‘æ‰‹å†™é‡å¤ä»£ç 

**å®˜æ–¹æ–‡æ¡£**: https://gorm.io/gen/

---

## é¡¹ç›®ä¸­çš„ä½¿ç”¨

### æ–‡ä»¶ç»“æž„

åœ¨ Coze Studio é¡¹ç›®ä¸­ï¼Œæ¯ä¸ª Domain çš„æ•°æ®è®¿é—®å±‚éƒ½ä½¿ç”¨ GORM Genï¼š

```
backend/domain/user/internal/dal/
â”œâ”€â”€ model/                    # ç”Ÿæˆçš„æ¨¡åž‹
â”‚   â”œâ”€â”€ user.gen.go          # User æ¨¡åž‹ï¼ˆè‡ªåŠ¨ç”Ÿæˆï¼‰
â”‚   â”œâ”€â”€ space.gen.go         # Space æ¨¡åž‹ï¼ˆè‡ªåŠ¨ç”Ÿæˆï¼‰
â”‚   â””â”€â”€ space_user.gen.go    # SpaceUser æ¨¡åž‹ï¼ˆè‡ªåŠ¨ç”Ÿæˆï¼‰
â”‚
â”œâ”€â”€ query/                    # ç”Ÿæˆçš„æŸ¥è¯¢ä»£ç 
â”‚   â”œâ”€â”€ gen.go               # æŸ¥è¯¢å…¥å£ï¼ˆè‡ªåŠ¨ç”Ÿæˆï¼‰
â”‚   â”œâ”€â”€ user.gen.go          # User æŸ¥è¯¢ï¼ˆè‡ªåŠ¨ç”Ÿæˆï¼‰
â”‚   â”œâ”€â”€ space.gen.go         # Space æŸ¥è¯¢ï¼ˆè‡ªåŠ¨ç”Ÿæˆï¼‰
â”‚   â””â”€â”€ space_user.gen.go    # SpaceUser æŸ¥è¯¢ï¼ˆè‡ªåŠ¨ç”Ÿæˆï¼‰
â”‚
â”œâ”€â”€ user.go                   # DAO å®žçŽ°ï¼ˆæ‰‹å†™ï¼‰â­ï¸
â”œâ”€â”€ space.go                  # DAO å®žçŽ°ï¼ˆæ‰‹å†™ï¼‰
â””â”€â”€ space_user.go             # DAO å®žçŽ°ï¼ˆæ‰‹å†™ï¼‰
```

**é‡è¦**:
- `.gen.go` æ–‡ä»¶æ˜¯**è‡ªåŠ¨ç”Ÿæˆ**çš„ï¼Œä¸è¦æ‰‹åŠ¨ä¿®æ”¹
- `.go` æ–‡ä»¶ï¼ˆå¦‚ `user.go`ï¼‰æ˜¯**æ‰‹å†™**çš„ DAO å®žçŽ°

---

## ç”Ÿæˆçš„ä»£ç ç»“æž„

### 1. Model (æ¨¡åž‹)

**æ–‡ä»¶**: `domain/user/internal/dal/model/user.gen.go`

```go
// Code generated by gorm.io/gen. DO NOT EDIT.
package model

type User struct {
    ID           int64          `gorm:"column:id;primaryKey"`
    Name         string         `gorm:"column:name;not null"`
    UniqueName   string         `gorm:"column:unique_name;not null"`
    Email        string         `gorm:"column:email;not null"`
    Password     string         `gorm:"column:password;not null"`
    Description  string         `gorm:"column:description;not null"`
    IconURI      string         `gorm:"column:icon_uri;not null"`
    UserVerified bool           `gorm:"column:user_verified;not null"`
    Locale       string         `gorm:"column:locale;not null"`
    SessionKey   string         `gorm:"column:session_key;not null"`
    CreatedAt    int64          `gorm:"column:created_at;not null;autoCreateTime:milli"`
    UpdatedAt    int64          `gorm:"column:updated_at;not null;autoUpdateTime:milli"`
    DeletedAt    gorm.DeletedAt `gorm:"column:deleted_at"`
}

func (*User) TableName() string {
    return "user"
}
```

**ç‰¹ç‚¹**:
- å®Œå…¨å¯¹åº”æ•°æ®åº“è¡¨ç»“æž„
- åŒ…å«æ‰€æœ‰ GORM æ ‡ç­¾
- è‡ªåŠ¨å¤„ç†æ—¶é—´æˆ³ï¼ˆæ¯«ç§’ï¼‰

---

### 2. Query (æŸ¥è¯¢å¯¹è±¡)

**æ–‡ä»¶**: `domain/user/internal/dal/query/user.gen.go`

```go
// Code generated by gorm.io/gen. DO NOT EDIT.
package query

type user struct {
    userDo
    
    ALL          field.Asterisk
    ID           field.Int64  // ç±»åž‹å®‰å…¨çš„å­—æ®µ
    Name         field.String
    UniqueName   field.String
    Email        field.String
    Password     field.String
    Description  field.String
    IconURI      field.String
    UserVerified field.Bool
    Locale       field.String
    SessionKey   field.String
    CreatedAt    field.Int64
    UpdatedAt    field.Int64
    DeletedAt    field.Field
}

// ç±»åž‹å®‰å…¨çš„æ–¹æ³•
func (u *user) Where(conds ...gen.Condition) *user
func (u *user) Select(cols ...field.Expr) *user
func (u *user) First() (*model.User, error)
func (u *user) Find() ([]*model.User, error)
func (u *user) Count() (int64, error)
// ... æ›´å¤šæ–¹æ³•
```

**ç‰¹ç‚¹**:
- æ¯ä¸ªå­—æ®µéƒ½æ˜¯ç±»åž‹å®‰å…¨çš„
- æ”¯æŒé“¾å¼è°ƒç”¨
- è‡ªåŠ¨ç”Ÿæˆå¸¸ç”¨æŸ¥è¯¢æ–¹æ³•

---

### 3. Query Entry (æŸ¥è¯¢å…¥å£)

**æ–‡ä»¶**: `domain/user/internal/dal/query/gen.go`

```go
// Code generated by gorm.io/gen. DO NOT EDIT.
package query

import "gorm.io/gorm"

type Query struct {
    db *gorm.DB
    
    User      user      // User æŸ¥è¯¢å¯¹è±¡
    Space     space     // Space æŸ¥è¯¢å¯¹è±¡
    SpaceUser spaceUser // SpaceUser æŸ¥è¯¢å¯¹è±¡
}

func Use(db *gorm.DB) *Query {
    return &Query{
        db:        db,
        User:      newUser(db),
        Space:     newSpace(db),
        SpaceUser: newSpaceUser(db),
    }
}
```

**ç‰¹ç‚¹**:
- ç»Ÿä¸€çš„æŸ¥è¯¢å…¥å£
- ç®¡ç†æ‰€æœ‰è¡¨çš„æŸ¥è¯¢å¯¹è±¡

---

## å¦‚ä½•ä½¿ç”¨

### 1. åœ¨ DAO ä¸­ä½¿ç”¨

**æ–‡ä»¶**: `domain/user/internal/dal/user.go`

```go
package dal

import (
    "context"
    "errors"
    
    "gorm.io/gorm"
    
    "github.com/coze-dev/coze-studio/backend/domain/user/internal/dal/model"
    "github.com/coze-dev/coze-studio/backend/domain/user/internal/dal/query"
)

// UserDAO ç”¨æˆ·æ•°æ®è®¿é—®å¯¹è±¡
type UserDAO struct {
    query *query.Query  // GORM Gen æŸ¥è¯¢å¯¹è±¡
}

// NewUserDAO åˆ›å»º UserDAO
func NewUserDAO(db *gorm.DB) *UserDAO {
    return &UserDAO{
        query: query.Use(db),  // ä½¿ç”¨ GORM Gen
    }
}
```

---

### 2. ç±»åž‹å®‰å…¨çš„æŸ¥è¯¢

#### ç¤ºä¾‹ 1: é€šè¿‡ ID æŸ¥è¯¢

```go
func (dao *UserDAO) GetUserByID(ctx context.Context, userID int64) (*model.User, error) {
    // âœ… ç±»åž‹å®‰å…¨ï¼šdao.query.User.ID.Eq(userID)
    return dao.query.User.WithContext(ctx).
        Where(dao.query.User.ID.Eq(userID)).  // ç¼–è¯‘æ—¶æ£€æŸ¥ç±»åž‹
        First()
}
```

**å¯¹æ¯”ä¼ ç»Ÿ GORM**:
```go
// âŒ ä¼ ç»Ÿæ–¹å¼ï¼šå­—ç¬¦ä¸²æ‹¼æŽ¥ï¼Œå®¹æ˜“å‡ºé”™
db.Where("id = ?", userID).First(&user)

// âœ… GORM Genï¼šç±»åž‹å®‰å…¨
dao.query.User.Where(dao.query.User.ID.Eq(userID)).First()
```

---

#### ç¤ºä¾‹ 2: é€šè¿‡é‚®ç®±æŸ¥è¯¢

```go
func (dao *UserDAO) GetUsersByEmail(ctx context.Context, email string) (*model.User, bool, error) {
    user, err := dao.query.User.WithContext(ctx).
        Where(dao.query.User.Email.Eq(email)).  // ç±»åž‹å®‰å…¨
        First()
    
    if errors.Is(err, gorm.ErrRecordNotFound) {
        return nil, false, nil  // æœªæ‰¾åˆ°
    }
    
    if err != nil {
        return nil, false, err  // å…¶ä»–é”™è¯¯
    }
    
    return user, true, nil  // æ‰¾åˆ°
}
```

---

#### ç¤ºä¾‹ 3: æ›´æ–°æ“ä½œ

```go
func (dao *UserDAO) UpdateProfile(ctx context.Context, userID int64, updates map[string]interface{}) error {
    // è‡ªåŠ¨æ·»åŠ æ›´æ–°æ—¶é—´
    if _, ok := updates["updated_at"]; !ok {
        updates["updated_at"] = time.Now().UnixMilli()
    }
    
    _, err := dao.query.User.WithContext(ctx).
        Where(dao.query.User.ID.Eq(userID)).
        Updates(updates)
    
    return err
}
```

---

#### ç¤ºä¾‹ 4: åˆ›å»ºè®°å½•

```go
func (dao *UserDAO) CreateUser(ctx context.Context, user *model.User) error {
    return dao.query.User.WithContext(ctx).Create(user)
}
```

---

#### ç¤ºä¾‹ 5: æ‰¹é‡æŸ¥è¯¢

```go
func (dao *UserDAO) GetUsersByIDs(ctx context.Context, userIDs []int64) ([]*model.User, error) {
    return dao.query.User.WithContext(ctx).
        Where(dao.query.User.ID.In(userIDs...)).  // In æŸ¥è¯¢
        Find()
}
```

---

#### ç¤ºä¾‹ 6: å¤æ‚æŸ¥è¯¢

```go
func (dao *UserDAO) SearchUsers(ctx context.Context, keyword string, limit int) ([]*model.User, error) {
    return dao.query.User.WithContext(ctx).
        Where(
            dao.query.User.Name.Like("%" + keyword + "%").
                Or(dao.query.User.Email.Like("%" + keyword + "%")),
        ).
        Limit(limit).
        Order(dao.query.User.CreatedAt.Desc()).
        Find()
}
```

---

### 3. æ”¯æŒçš„æŸ¥è¯¢æ¡ä»¶

GORM Gen ä¸ºæ¯ç§å­—æ®µç±»åž‹ç”Ÿæˆä¸åŒçš„æ–¹æ³•ï¼š

#### String å­—æ®µæ–¹æ³•
```go
dao.query.User.Name.Eq("å¼ ä¸‰")           // = "å¼ ä¸‰"
dao.query.User.Name.Neq("æŽå››")          // != "æŽå››"
dao.query.User.Name.In("å¼ ä¸‰", "æŽå››")    // IN ("å¼ ä¸‰", "æŽå››")
dao.query.User.Name.NotIn("çŽ‹äº”")         // NOT IN ("çŽ‹äº”")
dao.query.User.Name.Like("%å¼ %")          // LIKE "%å¼ %"
dao.query.User.Name.NotLike("%æŽ%")       // NOT LIKE "%æŽ%"
```

#### Int64 å­—æ®µæ–¹æ³•
```go
dao.query.User.ID.Eq(123)         // = 123
dao.query.User.ID.Neq(456)        // != 456
dao.query.User.ID.Gt(100)         // > 100
dao.query.User.ID.Gte(100)        // >= 100
dao.query.User.ID.Lt(1000)        // < 1000
dao.query.User.ID.Lte(1000)       // <= 1000
dao.query.User.ID.Between(1, 100) // BETWEEN 1 AND 100
dao.query.User.ID.In(1, 2, 3)     // IN (1, 2, 3)
```

#### Bool å­—æ®µæ–¹æ³•
```go
dao.query.User.UserVerified.Is(true)   // = true
dao.query.User.UserVerified.Is(false)  // = false
```

#### ç»„åˆæ¡ä»¶
```go
// AND
dao.query.User.Where(
    dao.query.User.Name.Eq("å¼ ä¸‰"),
    dao.query.User.UserVerified.Is(true),
)

// OR
dao.query.User.Where(
    dao.query.User.Name.Eq("å¼ ä¸‰").
        Or(dao.query.User.Email.Eq("test@example.com")),
)
```

---

## å®žé™…ç¤ºä¾‹

### å®Œæ•´çš„ DAO å®žçŽ°

è¿™æ˜¯é¡¹ç›®ä¸­å®žé™…çš„ `user.go` æ–‡ä»¶ï¼š

```go
package dal

import (
    "context"
    "errors"
    "time"
    
    "gorm.io/gorm"
    
    "github.com/coze-dev/coze-studio/backend/domain/user/internal/dal/model"
    "github.com/coze-dev/coze-studio/backend/domain/user/internal/dal/query"
)

func NewUserDAO(db *gorm.DB) *UserDAO {
    return &UserDAO{
        query: query.Use(db),
    }
}

type UserDAO struct {
    query *query.Query
}

// GetUsersByEmail é€šè¿‡é‚®ç®±èŽ·å–ç”¨æˆ·
func (dao *UserDAO) GetUsersByEmail(ctx context.Context, email string) (*model.User, bool, error) {
    user, err := dao.query.User.WithContext(ctx).
        Where(dao.query.User.Email.Eq(email)).
        First()
    
    if errors.Is(err, gorm.ErrRecordNotFound) {
        return nil, false, nil
    }
    
    if err != nil {
        return nil, false, err
    }
    
    return user, true, err
}

// UpdateSessionKey æ›´æ–° Session Key
func (dao *UserDAO) UpdateSessionKey(ctx context.Context, userID int64, sessionKey string) error {
    _, err := dao.query.User.WithContext(ctx).
        Where(dao.query.User.ID.Eq(userID)).
        Updates(map[string]interface{}{
            "session_key": sessionKey,
            "updated_at":  time.Now().UnixMilli(),
        })
    return err
}

// ClearSessionKey æ¸…é™¤ Session Key
func (dao *UserDAO) ClearSessionKey(ctx context.Context, userID int64) error {
    _, err := dao.query.User.WithContext(ctx).
        Where(dao.query.User.ID.Eq(userID)).
        UpdateColumn(dao.query.User.SessionKey, "")
    
    return err
}

// UpdatePassword æ›´æ–°å¯†ç 
func (dao *UserDAO) UpdatePassword(ctx context.Context, email, password string) error {
    _, err := dao.query.User.WithContext(ctx).
        Where(dao.query.User.Email.Eq(email)).
        Updates(map[string]interface{}{
            "password":    password,
            "session_key": "", // æ¸…é™¤ session key
            "updated_at":  time.Now().UnixMilli(),
        })
    return err
}

// GetUserByID é€šè¿‡ ID èŽ·å–ç”¨æˆ·
func (dao *UserDAO) GetUserByID(ctx context.Context, userID int64) (*model.User, error) {
    return dao.query.User.WithContext(ctx).
        Where(dao.query.User.ID.Eq(userID)).
        First()
}

// UpdateAvatar æ›´æ–°å¤´åƒ
func (dao *UserDAO) UpdateAvatar(ctx context.Context, userID int64, iconURI string) error {
    _, err := dao.query.User.WithContext(ctx).
        Where(dao.query.User.ID.Eq(userID)).
        Updates(map[string]interface{}{
            "icon_uri":   iconURI,
            "updated_at": time.Now().UnixMilli(),
        })
    return err
}

// CheckUniqueNameExist æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å­˜åœ¨
func (dao *UserDAO) CheckUniqueNameExist(ctx context.Context, uniqueName string) (bool, error) {
    _, err := dao.query.User.WithContext(ctx).
        Select(dao.query.User.ID).
        Where(dao.query.User.UniqueName.Eq(uniqueName)).
        First()
    
    if errors.Is(err, gorm.ErrRecordNotFound) {
        return false, nil
    }
    if err != nil {
        return false, err
    }
    return true, nil
}

// UpdateProfile æ›´æ–°ç”¨æˆ·èµ„æ–™
func (dao *UserDAO) UpdateProfile(ctx context.Context, userID int64, updates map[string]interface{}) error {
    if _, ok := updates["updated_at"]; !ok {
        updates["updated_at"] = time.Now().UnixMilli()
    }
    
    _, err := dao.query.User.WithContext(ctx).
        Where(dao.query.User.ID.Eq(userID)).
        Updates(updates)
    return err
}

// CheckEmailExist æ£€æŸ¥é‚®ç®±æ˜¯å¦å­˜åœ¨
func (dao *UserDAO) CheckEmailExist(ctx context.Context, email string) (bool, error) {
    _, exist, err := dao.GetUsersByEmail(ctx, email)
    if !exist {
        return false, nil
    }
    
    if err != nil {
        return false, err
    }
    
    return true, nil
}

// CreateUser åˆ›å»ºç”¨æˆ·
func (dao *UserDAO) CreateUser(ctx context.Context, user *model.User) error {
    return dao.query.User.WithContext(ctx).Create(user)
}

// GetUserBySessionKey é€šè¿‡ Session Key æŸ¥è¯¢ç”¨æˆ·
func (dao *UserDAO) GetUserBySessionKey(ctx context.Context, sessionKey string) (*model.User, bool, error) {
    user, err := dao.query.User.WithContext(ctx).
        Where(dao.query.User.SessionKey.Eq(sessionKey)).
        First()
    
    if errors.Is(err, gorm.ErrRecordNotFound) {
        return nil, false, nil
    }
    if err != nil {
        return nil, false, err
    }
    
    return user, true, nil
}

// GetUsersByIDs æ‰¹é‡æŸ¥è¯¢ç”¨æˆ·
func (dao *UserDAO) GetUsersByIDs(ctx context.Context, userIDs []int64) ([]*model.User, error) {
    return dao.query.User.WithContext(ctx).
        Where(dao.query.User.ID.In(userIDs...)).
        Find()
}
```

---

## æœ€ä½³å®žè·µ

### 1. å§‹ç»ˆä½¿ç”¨ WithContext

```go
// âœ… æ­£ç¡®ï¼šä½¿ç”¨ WithContext
dao.query.User.WithContext(ctx).Where(...).First()

// âŒ é”™è¯¯ï¼šå¿˜è®° WithContext
dao.query.User.Where(...).First()
```

**åŽŸå› **: WithContext æ”¯æŒè¯·æ±‚å–æ¶ˆã€è¶…æ—¶æŽ§åˆ¶å’Œé“¾è·¯è¿½è¸ªã€‚

---

### 2. é”™è¯¯å¤„ç†

```go
// âœ… æ­£ç¡®ï¼šåŒºåˆ†æœªæ‰¾åˆ°å’Œå…¶ä»–é”™è¯¯
user, err := dao.query.User.WithContext(ctx).First()
if errors.Is(err, gorm.ErrRecordNotFound) {
    return nil, errors.New("user not found")
}
if err != nil {
    return nil, err
}

// âŒ é”™è¯¯ï¼šæ‰€æœ‰é”™è¯¯éƒ½å½“ä½œæœªæ‰¾åˆ°
user, err := dao.query.User.WithContext(ctx).First()
if err != nil {
    return nil, errors.New("user not found")
}
```

---

### 3. æ›´æ–°æ—¶è‡ªåŠ¨è®¾ç½®æ—¶é—´æˆ³

```go
// âœ… æ­£ç¡®ï¼šè‡ªåŠ¨æ·»åŠ  updated_at
func (dao *UserDAO) UpdateProfile(ctx context.Context, userID int64, updates map[string]interface{}) error {
    if _, ok := updates["updated_at"]; !ok {
        updates["updated_at"] = time.Now().UnixMilli()
    }
    
    _, err := dao.query.User.WithContext(ctx).
        Where(dao.query.User.ID.Eq(userID)).
        Updates(updates)
    return err
}
```

---

### 4. ä½¿ç”¨ Select ä¼˜åŒ–æŸ¥è¯¢

```go
// âœ… åªæŸ¥è¯¢éœ€è¦çš„å­—æ®µ
dao.query.User.WithContext(ctx).
    Select(dao.query.User.ID, dao.query.User.Name, dao.query.User.Email).
    Where(dao.query.User.ID.Eq(userID)).
    First()

// âŒ æŸ¥è¯¢æ‰€æœ‰å­—æ®µï¼ˆå¯èƒ½åŒ…å«å¤§å­—æ®µï¼‰
dao.query.User.WithContext(ctx).
    Where(dao.query.User.ID.Eq(userID)).
    First()
```

---

### 5. æ‰¹é‡æ“ä½œä½¿ç”¨äº‹åŠ¡

```go
// âœ… ä½¿ç”¨äº‹åŠ¡ä¿è¯ä¸€è‡´æ€§
err := dao.query.Transaction(func(tx *query.Query) error {
    // åˆ›å»ºç”¨æˆ·
    if err := tx.User.WithContext(ctx).Create(user); err != nil {
        return err
    }
    
    // åˆ›å»ºç©ºé—´
    if err := tx.Space.WithContext(ctx).Create(space); err != nil {
        return err
    }
    
    return nil
})
```

---

## ðŸŽ¯ æ€»ç»“

### GORM Gen çš„ä¼˜åŠ¿

1. **ç±»åž‹å®‰å…¨** âœ…
   - ç¼–è¯‘æ—¶æ£€æŸ¥ï¼Œé¿å…å­—æ®µåæ‹¼å†™é”™è¯¯
   - IDE è‡ªåŠ¨è¡¥å…¨

2. **ä»£ç ç®€æ´** âœ…
   - é“¾å¼è°ƒç”¨ï¼Œä»£ç æ›´ä¼˜é›…
   - å‡å°‘é‡å¤ä»£ç 

3. **æ˜“äºŽç»´æŠ¤** âœ…
   - è¡¨ç»“æž„å˜æ›´åŽé‡æ–°ç”Ÿæˆå³å¯
   - è‡ªåŠ¨åŒæ­¥æ•°æ®åº“ç»“æž„

4. **æ€§èƒ½ä¼˜åŒ–** âœ…
   - è‡ªåŠ¨ç”Ÿæˆé«˜æ•ˆæŸ¥è¯¢
   - æ”¯æŒé¢„ç¼–è¯‘

### åœ¨ Coze Studio ä¸­çš„ä½¿ç”¨

- âœ… æ‰€æœ‰ Domain çš„æ•°æ®è®¿é—®éƒ½ä½¿ç”¨ GORM Gen
- âœ… `.gen.go` æ–‡ä»¶è‡ªåŠ¨ç”Ÿæˆï¼Œä¸è¦ä¿®æ”¹
- âœ… `.go` æ–‡ä»¶æ‰‹å†™ DAO å®žçŽ°
- âœ… é€šè¿‡ Repository æŽ¥å£ä¸Ž Domain å±‚è§£è€¦

### å­¦ä¹ å»ºè®®

1. ðŸ“– é˜…è¯» `backend/domain/user/internal/dal/user.go`
2. ðŸ” ç†è§£ç”Ÿæˆçš„ä»£ç ç»“æž„
3. ðŸ’» å°è¯•ç¼–å†™è‡ªå·±çš„ DAO æ–¹æ³•
4. ðŸ§ª å‚è€ƒå®žé™…ä»£ç ä¸­çš„æœ€ä½³å®žè·µ

---

**å‚è€ƒèµ„æ–™**:
- GORM Gen å®˜æ–¹æ–‡æ¡£: https://gorm.io/gen/
- GORM å®˜æ–¹æ–‡æ¡£: https://gorm.io/zh_CN/

**ä¸‹ä¸€æ­¥**: é˜…è¯» [`BACKEND_IDL_GUIDE.md`](./BACKEND_IDL_GUIDE.md) äº†è§£ IDL é©±åŠ¨å¼€å‘æµç¨‹

